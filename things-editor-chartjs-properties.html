<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/paper-styles.html">
<link rel="import" href="../../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../../bower_components/iron-image/iron-image.html">

<link rel="import" href="../../bower_components/things-designer-elements/things-editor-multiple-color.html">
<link rel="import" href="../../bower_components/things-designer-elements/things-editor-number-input.html">

<dom-module id="things-editor-chartjs-properties">
  <template>
    <style>
      :host {
        @apply(--things-properties-panel);
      }
      label{
        @apply(--things-label);
      }
      input{
        @apply(--things-input);
      }
      fieldset{
        @apply(--things-fieldset);
      }
      legend{
        @apply(--things-fieldset-legend);
      }
      select{
        @apply(--things-select);
        background:url(/images/bg-input-select.png) 100% 50% no-repeat #fff;
      }
       things-editor-script{
        width:94%;
        height:300px;
        margin:0 0 7px 7px;
        overflow:auto;
      }
      paper-tabs{
        width:229px;height:25px;
        margin:-5px 0 0 7px;
        border:1px solid rgba(0,0,0,.2);
        border-width:1px 1px 0 1px;
      }
      paper-tabs::shadow #selectionBar.paper-tabs{background-color:transparent;}
      paper-tab{
        background-color:rgba(0,0,0,.2);
        border:1px solid rgba(0,0,0,.07);
        border-width:0 1px 0 0;
        padding:0 5px;
        color:#fff;
        font-size:13px;
      }
      paper-tab[disabled]{background-color:rgba(0,0,0,.1);}
      paper-tab:last-child{border-width:0;}
      paper-tab.iron-selected{
        background-color:rgba(255,255,255,.5);
        color:#585858;
      }
      .tab-content{
        background-color:rgba(255,255,255,.5);
        border:1px solid rgba(0,0,0,.2);
        border-width:0 1px 1px 1px;
        margin:0 7px 10px 7px;padding:7px 5px 0 5px;
      }
      .tab-content label{
        width:40%;
      }
      .tab-content input{
        width:52%;
      }
      .same-width input[type="checkbox"]{
        width:15px;
      }
      .same-width label{
        top:0;
      }
    </style>

    <form class="content" method="post">
      <fieldset class="same-width">
        <legend>
          <things-i18n-msg msgid="label.chart" auto>Chart</things-i18n-msg>
        </legend>
        <label>
          <things-i18n-msg msgid="label.theme" auto>theme</things-i18n-msg>
        </label>
        <select class="select-content" value="{{values.options.theme::change}}">
          <option value="dark">dark</option>
          <option value="light">light</option>
        </select>

        <div class="merge-column">
          <label>
            <things-i18n-msg msgid="label.legend" auto>Legend</things-i18n-msg>
          </label>
          <input type="checkbox" checked="{{values.options.legend.display::change}}" required>
          <things-i18n-msg msgid="" auto>show</things-i18n-msg>
        </div>
        <!-- <label>
          <things-i18n-msg msgid="label.show-legend" auto>Legend</things-i18n-msg>
        </label>
        <input type="checkbox" checked="{{values.options.legend.display}}" on-change="onDisplayLegendChanged" required> -->
        <label>
          <things-i18n-msg msgid="label.position" auto>Position</things-i18n-msg>
        </label>
        <select class="select-content" value="{{values.options.legend.position::change}}">
          <option value="top">top</option>
          <option value="right">right</option>
          <option value="bottom">bottom</option>
          <option value="left">left</option>
        </select>
        <label>
          <things-i18n-msg msgid="label.font-size" auto>Font Size</things-i18n-msg>
        </label>
        <input is="things-editor-number-input" number="{{values.options.fontSize::change}}">
        <template is="dom-if" if="[[_isAvailableOption(model, 'stacked')]]">
          <label>
            <things-i18n-msg msgid="label.stacked" auto>stacked</things-i18n-msg>
          </label>
          <input type="checkbox" checked="{{values.options.stacked}}" on-change="onStackedChanged" required>
          <label>
            <things-i18n-msg msgid="label.multi-axis" auto>Multi Axis</things-i18n-msg>
          </label>
          <input type="checkbox" checked="{{values.options.multiAxis}}" on-change="onMultiAxisChanged" required>
        </template>
      </fieldset>
      <fieldset>
        <legend>
          <things-i18n-msg msgid="label.series" auto>Series</things-i18n-msg>
        </legend>
        <template is="dom-if" if="[[!_isSpcChart(values)]]">
          <paper-tabs selected="{{currentSeriesIndex}}">
            <paper-tab data-series="1">1</paper-tab>
            <paper-tab data-series="2">2</paper-tab>
            <paper-tab data-series="3">3</paper-tab>
            <paper-tab data-series="4">4</paper-tab>
            <paper-tab data-series="5">5</paper-tab>
            <paper-tab data-series="6">6</paper-tab>
            <paper-tab data-series="7">7</paper-tab>
          </paper-tabs>
        </template>
        <div class="tab-content">
          <template is="dom-if" if="[[_isAvailableOption(model, 'type')]]">
            <label>
              <things-i18n-msg msgid="label.type" auto>type</things-i18n-msg>
            </label>
            <select class="select-content" value="{{series.type::change}}">
              <option value=""></option>
              <option value="bar">bar</option>
              <option value="line">line</option>
            </select>
          </template>
          <label>
            <things-i18n-msg msgid="label.label" auto>label</things-i18n-msg>
          </label>
          <input type="text" value="{{series.label::change}}"></input>
          <label>
            <things-i18n-msg msgid="label.line-tension" auto>line tension</things-i18n-msg>
          </label>
          <input is="things-editor-number-input" number="{{series.lineTension::change}}">
          <label>
            <things-i18n-msg msgid="label.border-color" auto>border color</things-i18n-msg>
          </label>
          <things-editor-color value="{{series.borderColor::change}}"></things-editor-color>
          <label>
            <things-i18n-msg msgid="label.border-width" auto>border width</things-i18n-msg>
          </label>
          <input is="things-editor-number-input" number="{{series.borderWidth::change}}">
          <label>
            <things-i18n-msg msgid="label.background-color" auto>background color</things-i18n-msg>
          </label>
          <template is="dom-if" if="[[_usingMutiColor(model)]]">
            <things-editor-multiple-color values="{{series.backgroundColor}}"></things-editor-multiple-color>
          </template>
          <template is="dom-if" if="[[!_usingMutiColor(model)]]">
            <things-editor-color value="{{series.backgroundColor::change}}"></things-editor-color>
          </template>
          <label>
            <things-i18n-msg msgid="label.point-border-color" auto>point border color</things-i18n-msg>
          </label>
          <things-editor-color value="{{series.pointBorderColor::change}}"></things-editor-color>
          <label>
            <things-i18n-msg msgid="label.point-border-width" auto>point border width</things-i18n-msg>
          </label>
          <input is="things-editor-number-input" number="{{series.pointBorderWidth::change}}">
          <label>
            <things-i18n-msg msgid="label.point-bg-color" auto>point BG color</things-i18n-msg>
          </label>
          <things-editor-color value="{{series.pointBackgroundColor::change}}"></things-editor-color>
          <label>
            <things-i18n-msg msgid="label.fill" auto>fill</things-i18n-msg>
          </label>
          <input type="checkbox" checked="{{series.fill}}" on-change="onFillChanged" required>
          <label>
            <things-i18n-msg msgid="label.target-axis" auto>target axis</things-i18n-msg>
          </label>
          <select class="select-content" value="{{series.yAxisID::change}}">
            <option value="right">right</option>
            <option value="left">left</option>
          </select>
        </div>
      </fieldset>
      <fieldset class="same-width">
        <legend>
          <things-i18n-msg msgid="label.axes" auto>Axes</things-i18n-msg>
        </legend>
        <label>
          <things-i18n-msg msgid="label.x-grid-line" auto>X grid line</things-i18n-msg>
        </label>
        <input type="checkbox" checked="{{values.options.xGridLine}}" on-change="onXGridLineChanged" required>
        <label>
          <things-i18n-msg msgid="label.y-grid-line" auto>Y grid line</things-i18n-msg>
        </label>
        <input type="checkbox" checked="{{values.options.yGridLine}}" on-change="onYGridLineChanged" required>
      </fieldset>
      <fieldset class="same-width">
          <legend>
            <things-i18n-msg msgid="label.data" auto>data</things-i18n-msg>
          </legend>
          <div data-rule-type="eval">
            <things-editor-script id="eval-editor"
                                  theme="ace/theme/monokai"
                                  mode="ace/mode/javascript"
                                  value="{{dataString}}">
            </things-editor-script>
          </div>
      </fieldset>
      <template is="dom-if" if="[[_isSpcChart(values)]]">
        <fieldset class="same-width">
          <legend>
            <things-i18n-msg msgid="label.spc-option" auto>SPC Option</things-i18n-msg>
          </legend>
          <label>
            <things-i18n-msg msgid="label.ucl/lcl-border-color" auto>UCL/LCL Border Color</things-i18n-msg>
          </label>
          <things-editor-color values="{{values.options.spc.limitBorderColor}}" on-change="onControlLimitBorderColorChanged"></things-editor-color>
          <label>
            <things-i18n-msg msgid="label.ucl/lcl-border-width" auto>UCL/LCL Border Width</things-i18n-msg>
          </label>
          <input type="number" values-as-number="{{values.options.spc.limitBorderWidth}}" on-change="">
          <label>
            <things-i18n-msg msgid="label.cl-border-color" auto>CL Border Color</things-i18n-msg>
          </label>
          <things-editor-color values="{{values.options.spc.centerLineBorderColor}}" on-change=""></things-editor-color>
          <label>
            <things-i18n-msg msgid="label.cl-border-width" auto>CL Border Width</things-i18n-msg>
          </label>
          <input type="number" values-as-number="{{values.options.spc.centerLineBorderWidth}}" on-change="">

        </fieldset>
      </template>
    </form>

  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'things-editor-chartjs-properties',

        properties: {
          model: {
            notify: true
          },
          values: {
            type: Object,
            notify: true,
            value: {}
          },
          data: {
            type : Object,
            notify: true
          },

          dataString: {
            type: String,
            notify: true,
            value: ""
          }
        },

        observers: [
          'onModelChanged(model.*)',
          'onSeriesChanged(series.*)',
          'onCurrentSeriesIndexChanged(currentSeriesIndex)',
          'onDataChanged(data)',
          'onDataStringChanged(dataString)'
        ],

        listeners: {
          'eval-editor.blur': 'onBlurEvalEditor',
          'eval-editor.editor-ready': 'onEditorReady'
        },

        onBlurEvalEditor: function(after) {
          this.set('data', this.$['eval-editor'].value)
        },

        onEditorReady: function(e) {
          // event.detail should be a ace-editor
          e.detail.renderer.setShowGutter(false);

          var data = this.get('data') || {}
          this.set('dataString', '')
          this.async(function() {
            this.set('dataString',JSON.stringify(data, null, '\t'))
          }, 1)
        },

        onModelChanged: function(model) {
          if(model.path === 'model' && !this.changedByChartMember) {

            this.set('currentSeriesIndex', null);
            this.set('currentSeriesIndex', 0);

            return;
          }
        },

        onDataChanged: function(data) {
          this.set('dataString', JSON.stringify(data, null, '\t'))
        },

        onDataStringChanged: function(dataString) {

          var value
          // var value = this.get('data') || {}
          try{
            eval(`value = ${dataString}`)
          } catch(e) {
          } finally {
            this.set('data', value)
          }
        },

        onSeriesChanged: function(change) {

          if(!this.values)
            return

          var self = this

          setTimeout(function() {
            var last = -1

            for(var i = 0;i < 7;i++) {
              var series = self.model.chart.data.datasets[i]
              var tab = self.querySelector(`paper-tab[data-series="${i + 1}"]`)

              if(series) {
                tab.active = true
                tab.disabled = false
                tab.setAttribute('has-set', true)

                last = i
              } else {
                tab.active = false
                tab.removeAttribute('has-set')
                if(last < i - 1) {
                  tab.disabled = true
                } else {
                  tab.disabled = false
                }
              }
            }

          }, 10)

          if(!change || change.path === 'series'){
            return
          }

          // if(!this.series.seriess)
          //   this.series.seriess = []

          var series = this.series

          if(!this.get('model.chart.data.datasets.#'+this.currentSeriesIndex)) {

            var chart = JSON.parse(JSON.stringify(this.get('values')))

            chart.data.datasets = []

            let datasets = chart.data.datasets

            for(var i in this.values.data.datasets) {
              datasets[i] = JSON.parse(JSON.stringify(this.values.data.datasets[i]));
            }

            datasets.push({
              data:[]
            });

            this.changedByChartMember = true;

            this.set('values', chart)

          }

          var keyStr = 'model.chart.data.datasets.#'+ this.currentSeriesIndex + '.' + change.path.replace('series.', '');

          this.set(keyStr, change.value)

          this.changedByChartMember = false;

          // var chart = JSON.parse(JSON.stringify(this.get('values.chart')))
          //
          // chart.data.datasets = []
          //
          // let datasets = chart.data.datasets
          //
          // for(var i in this.values.data.datasets) {
          //   datasets[i] = JSON.parse(JSON.stringify(this.values.data.datasets[i]));
          // }
          //
          // if(!this.get('values.data.datasets.#'+this.currentSeriesIndex)) {
          //
          //   datasets.push({
          //     data:[]
          //   });
          //
          //   this.set('values.chart', chart)
          // }
          //
          // datasets[this.currentSeriesIndex][change.path.replace('series.', '')] = change.value;
          //
          // // this.changedByChartMember = true;
          //
          // this.set('values.chart', chart)
          //
          // this.onCurrentSeriesIndexChanged(this.get('currentSeriesIndex'))
          // this.onSeriesChanged();

        },

        onCurrentSeriesIndexChanged: function(currentSeriesIndex) {
          if(!this.model.chart) {
            this.set('series', null)
            return
          }

          if(!this.model.chart.data.datasets)
            return

          this.set('series', this.model.chart.data.datasets[currentSeriesIndex] || {})

        },

        onFillChanged : function(e) {
          this.set("series.fill", e.target.checked)
        },

        onXGridLineChanged : function(e){

          var checked = e.target.checked
          try {
            var xAxes = this.get('values.options.scales.xAxes');
            for (let i in xAxes) {
              this.set("values.options.scales.xAxes.#"+i+".gridLines.display", checked);
            }

          } catch(e) {
          } finally {
              this.set("values.options.xGridLine", checked);
          }

        },

        onYGridLineChanged : function(e){

          var checked = e.target.checked
          try {
            var yAxes = this.get('values.options.scales.yAxes');
            for (let i in yAxes) {
              this.set("values.options.scales.yAxes.#"+i+".gridLines.display", checked);
            }

          } catch(e) {
          } finally {
              this.set("values.options.yGridLine", checked);
          }

        },

        onDisplayLegendChanged : function(e){
          var checked = e.target.checked
          if(!this.get("values.options")) {
            this.set("values.options", {})
          }

          if(!this.get("values.options.legend")) {
            this.set("values.options.legend", {})
          }

          this.set("values.options.legend.display", checked);
        },

        onControlLimitBorderColorChanged: function(e) {
          var value = e.target.value;

          try{

          }catch(e) {

          }
        },

        _isAvailableOption: function(model, optionName) {
          if(!model.chart)
            return false;

          var availableOptions = {
            bar : ['type', 'stacked'],
            line : ['type']
          }

          if(availableOptions[model.chart.type] &&
            availableOptions[model.chart.type].indexOf(optionName) >= 0) {
            return true;
          }

          return false;
        },

        _usingMutiColor: function(model) {

          if(!model.chart)
            return false;

          switch (model.chart.type) {
            case 'pie':
            case 'doughnut':
                return true;
            default:
              return false;
          }
        },

        _isSpcChart: function(values) {
          var isSPC = false;

          if(!values.type)
            return false;

          if(values.type == 'controlChart')
            isSPC =  true;

          return isSPC;
        },

        onStackedChanged: function(e){
          var checked = e.target.checked
          if(!this.get("values.options")) {
            this.set("values.options", {})
          }

          this.set("values.options.stacked", checked);
        },

        onMultiAxisChanged: function(e){
          var checked = e.target.checked
          if(!this.get("values.options")) {
            this.set("values.options", {})
          }

          this.set("values.options.multiAxis", checked);
        }

      })

    })();

  </script>
</dom-module>
